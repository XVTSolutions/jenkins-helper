// This Jenkinsfile is for building a generic dotnetcore project with sonar scan
pipeline {
    agent { label 'dotnetcore-docker' }
    stages {
        stage('Load jenkins-helper') {
            steps {
                script {
                    GIT_REVISION = sh(returnStdout: true, script: """##@echo off
                        git rev-parse --short HEAD"""
                    ).trim()
                    def PWD = pwd()
                    echo "Check out REVISION: $GIT_REVISION on $PWD"

                    BUILD_VERSION_PREFIX = "${GIT_BRANCH}-${GIT_REVISION}-".replace('/', '-')
                    env.BUILD_VERSION = VersionNumber projectStartDate: '2018-11-07', versionNumberString: "${BUILD_NUMBER}", versionPrefix: "${BUILD_VERSION_PREFIX}", worstResultForIncrement: 'SUCCESS'
                    echo "Version:  $BUILD_VERSION"
                    echo "Revision: $GIT_REVISION"
                    checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: true, extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: 'jenkins-helper'], [$class: 'CloneOption', noTags: true, reference: '', shallow: true]], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'xvt-product-registration1', url: 'git@github.com:XVTSolutions/jenkins-helper.git']]])
                    utils = load("${WORKSPACE}/jenkins-helper/deployment.groovy")
                    utils.generate_add_user_script()
                }//script
            }//steps
        }//stage

        stage('Generating Deploy Scripts') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'sonar_login', passwordVariable: 'SONAR_TOKEN', usernameVariable: 'SONAR_URL')]) {
                    sh '''cat <<EOF > build.sh
#!/bin/bash -e

cd tools/Minicover/
dotnet restore Minicover.csproj

cd ${WORKSPACE}

dotnet restore --configfile "nuget.config"

# Build/Publish with restore (in case the cache isn't complete)
dotnet sonarscanner begin \
        /k:"${SONAR_PROJECT}" \
        /n:"${SONAR_PROJECT}" \
        /v:"${BUILD_VERSION}" \
        /d:sonar.host.url="${SONAR_URL}" \
        /d:sonar.login="${SONAR_TOKEN}" \
        /d:sonar.cs.opencover.reportsPaths="test/opencovercoverage.xml" \
        /d:sonar.coverage.exclusions="test/**/*"

dotnet build --no-restore

# Start instrumentation
cd tools/Minicover/
dotnet restore Minicover.csproj
dotnet minicover instrument --workdir ${WORKSPACE} --assemblies test/**/*.dll --sources src/**/*.cs
dotnet minicover reset

cd ${WORKSPACE}

# Run each of the test projects and save the results
for csproj in ./test/**/*.csproj; \
    do \
        trx=$(basename $csproj); \
        dotnet test \
            --no-build \
            --logger "trx;LogFileName=test/$trx.trx" \
            $csproj; \
        exit_status=$?; \
        if [ ! $exit_status -eq 0 ]; \
        then \
            exit $exit_status; \
        fi; \
done

# Uninstrument and generate reports
cd tools/Minicover

dotnet minicover uninstrument --workdir /src
dotnet minicover report --workdir ${WORKSPACE} --threshold 0 || true
dotnet minicover opencoverreport --workdir ${WORKSPACE} --threshold 0 || true

# Copy the Coverage results to the /test folder

mkdir -p ${WORKSPACE}/test

cp *coverage.* ${WORKSPACE}/test/

dotnet sonarscanner end \
        /d:sonar.login="${SONAR_TOKEN}"

EOF
'''
                    }
                    sh 'chmod +x build.sh'
                    sh 'cat build.sh'
                }//script
            }//steps
        }//stage

        stage('Run the generated scripts within the docker environment') {
            steps {
                script {
                    utils.run_build_script(['docker_image': 'xvtsolutions/dotnet-sdk-sonar-scanner:2.1.603'])
                } //script
            } // step
        } // stage
    } // stages
    post {
        always {
            script {
                currentBuild.description = """REVISION: ${GIT_REVISION}<br/>
"""
            }
        }
        success {
            script {
              echo 'Success!'
            }
        }
        failure {
            emailext attachLog: true, attachmentsPattern: "${BUILD_TAG}.log", body: """JOB $JOB_NAME on $NODE_NAME has finished.
BUILD_NUMBER: ${BUILD_NUMBER}
BUILD_URL: ${BUILD_URL}
""", compressLog: true, subject: "JOB $JOB_NAME on $NODE_NAME has finished", to: 'ops@xvt.com.au'
        }
        cleanup {
          script {
            sh "rm -f ${BUILD_TAG}.log"
          }//script
        }//cleanup
    }
} // pipeline